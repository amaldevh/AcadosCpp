// standard
#include <stdio.h>
#include <stdlib.h>
// acados
#include "acados/utils/print.h"
#include "acados/utils/math.h"
#include "acados_c/ocp_nlp_interface.h"
#include "acados_c/external_function_interface.h"
#include "acados_solver_{{model_name | lower}}.h"

// blasfeo
#include "blasfeo_d_aux_ext_dep.h"
#include <vector>
#include <string>
#include <iostream>


#define NX      {{model_name | upper}}_NX
#define NP      {{model_name | upper}}_NP
#define NU      {{model_name | upper}}_NU
#define NBX0    {{model_name | upper}}_NBX0
#define NP_GLOBAL    {{model_name | upper}}_NP_GLOBAL

class ModelOcp {
public:
    

    ModelOcp();

    /** @brief sets the x0 , initial state for solving the ocp */
    void set_x0(std::vector<double>& init_state);

    void set_xinit(const std::vector<double>& xinit);
    void set_uinit(const std::vector<double>& uinit);

    void set_yref(const std::vector<double>& xref, const std::vector<double>& uref);
    const std::vector<double>& solve();

    // uses previous u_opt as u_ref
    const std::vector<double>& solve(std::vector<double>& x0, const std::vector<double>& x_des);
    ~ModelOcp();
private:
    {{model_name | lower}}_solver_capsule *acados_ocp_capsule_;
    // there is an opportunity to change the number of shooting intervals in C without new code generation
    int N_ = {{model_name | upper}}_N;
    // allocate the array and fill it accordingly
    double* new_time_steps_ = NULL;
    int status_;

    ocp_nlp_config *nlp_config_;
    ocp_nlp_dims *nlp_dims_;
    ocp_nlp_in *nlp_in_;
    ocp_nlp_out *nlp_out_;
    ocp_nlp_solver *nlp_solver_;
    void *nlp_opts_;

    // solver metrics
    int NTIMINGS_ = 1;
    double min_time_ = 1e12;
    double kkt_norm_inf_;
    double elapsed_time_;
    int sqp_iter_;

    std::vector<double> xtraj_=std::vector<double>(NX * (N_+1), 0.0);
    std::vector<double> utraj_=std::vector<double>(NU * N_,  0.0);
    std::vector<double> x_init_=std::vector<double>(NX,  0.0);
    std::vector<double> u_init_=std::vector<double>(NU,  0.0);
    std::vector<double> x_ref_=std::vector<double>(NX,  0.0);
    std::vector<double> u_ref_=std::vector<double>(NU,  0.0);
    std::vector<double> y_ref_=std::vector<double>(NX + NU,  0.0);
    std::vector<double> u_opt_=std::vector<double>(NU,  0.0);

};

