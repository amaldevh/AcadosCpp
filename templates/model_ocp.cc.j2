#include "model_ocp.hh"

ModelOcp::ModelOcp(){

    acados_ocp_capsule_ = {{model_name | lower}}_acados_create_capsule();
    N_ = {{model_name | upper}}_N;
    new_time_steps_ = NULL;
    status_ = {{model_name | lower}}_acados_create_with_discretization(acados_ocp_capsule_,
            N_,
            new_time_steps_);

    if (status_)
    {
        printf("{{model_name | lower}}_acados_create() returned status %d. Exiting.\n", status_);
        exit(1);
    }

    nlp_config_ = {{model_name | lower}}_acados_get_nlp_config(acados_ocp_capsule_);
    nlp_dims_ = {{model_name | lower}}_acados_get_nlp_dims(acados_ocp_capsule_);
    nlp_in_ = {{model_name | lower}}_acados_get_nlp_in(acados_ocp_capsule_);
    nlp_out_ = {{model_name | lower}}_acados_get_nlp_out(acados_ocp_capsule_);
    nlp_solver_ = {{model_name | lower}}_acados_get_nlp_solver(acados_ocp_capsule_);
    nlp_opts_ = {{model_name | lower}}_acados_get_nlp_opts(acados_ocp_capsule_);
        
    };

/** @brief sets the x0 , initial state for solving the ocp */
void ModelOcp::set_x0(std::vector<double>& init_state){
    if (init_state.size() != NBX0)
        throw std::runtime_error("Expected initstate to have "+ std::to_string(NBX0)+ " elements");
    
    ocp_nlp_constraints_model_set(nlp_config_, nlp_dims_, nlp_in_, nlp_out_, 0, "lbx", init_state.data());
    ocp_nlp_constraints_model_set(nlp_config_, nlp_dims_, nlp_in_, nlp_out_, 0, "ubx", init_state.data());

    }


void ModelOcp::set_xinit(const std::vector<double>& xinit){
    if (xinit.size() != NX)
        throw std::runtime_error("Expected "+ std::to_string(NX)+" elements");
    x_init_ = xinit;
}
void ModelOcp::set_uinit(const std::vector<double>& uinit){
    if (uinit.size() != NU)
        throw std::runtime_error("Expected "+ std::to_string(NU)+" elements");
    u_init_ = uinit;
}

void ModelOcp::set_yref(const std::vector<double>& xref, const std::vector<double>& uref){
    if (xref.size() != NX) 
        throw std::runtime_error("Expected "+ std::to_string(NX)+" elements");
    if (uref.size() != NU)
        throw std::runtime_error("Expected "+ std::to_string(NU)+" elements");
    for (size_t i = 0; i< NX; ++i){
        y_ref_[i] = xref[i];
        x_ref_[i] = xref[i];
    }
    for (size_t i = 0; i<NU ;++i){
        y_ref_[NX+i] = uref[i];
        u_ref_[i] = uref[i];
    }
}
const std::vector<double>& ModelOcp::solve(){
    // solve ocp in loop
    for (int ii = 0; ii < NTIMINGS_; ii++)
    {
        // initialize solution
        for (int i = 0; i < N_; i++)
        {
            ocp_nlp_out_set(nlp_config_, nlp_dims_, nlp_out_, nlp_in_, i, "x", x_init_.data());
            ocp_nlp_out_set(nlp_config_, nlp_dims_, nlp_out_, nlp_in_, i, "u", u_init_.data());
            ocp_nlp_cost_model_set(nlp_config_, nlp_dims_, nlp_in_, i, "yref", y_ref_.data());
        }
        ocp_nlp_out_set(nlp_config_, nlp_dims_, nlp_out_, nlp_in_, N_, "x", x_init_.data());
        ocp_nlp_cost_model_set(nlp_config_, nlp_dims_, nlp_in_, N_, "yref", y_ref_.data());
        status_ = quadrotor_acados_solve(acados_ocp_capsule_);
        ocp_nlp_get(nlp_solver_, "time_tot", &elapsed_time_);
        min_time_= MIN(elapsed_time_, min_time_);
    }
        if (status_ != ACADOS_SUCCESS)
    {
        printf("quadrotor_acados_solve() failed with _ %d.\n", status_);
    }
        /* print solution and statistics */
    /*for (int ii = 0; ii <= nlp_dims_->N; ii++)
        ocp_nlp_out_get(nlp_config_, nlp_dims_, nlp_out_, ii, "x", &xtraj_[ii*NX]);
    for (int ii = 0; ii < nlp_dims_->N; ii++)
        ocp_nlp_out_get(nlp_config_, nlp_dims_, nlp_out_, ii, "u", &utraj_[ii*NU]);
    for (int ii = 0 ; ii < NU; ++ii){
        u_opt_[ii] = utraj_[ii];
    }*/
    
    // Get optimal control at first stage
    ocp_nlp_out_get(nlp_config_, nlp_dims_, nlp_out_, 0, "u", u_opt_.data());
    
    ocp_nlp_out_get(nlp_config_, nlp_dims_, nlp_out_, 0, "kkt_norm_inf", &kkt_norm_inf_);
    ocp_nlp_get(nlp_solver_, "sqp_iter", &sqp_iter_);

    return u_opt_;
}

// uses previous u_opt as u_ref
const std::vector<double>& ModelOcp::solve(std::vector<double>& x0, const std::vector<double>& x_des){
    set_uinit(u_opt_);
    set_xinit(x0);
    set_x0(x0);
    set_yref(x_des, u_opt_);
    return solve();
}
ModelOcp::~ModelOcp(){
        // free solver
    status_ = quadrotor_acados_free(acados_ocp_capsule_);
    if (status_) {
        printf("quadrotor_acados_free() returned status %d. \n", status_);
    }
    // free solver capsule
    status_ = quadrotor_acados_free_capsule(acados_ocp_capsule_);
    if (status_) {
        printf("quadrotor_acados_free_capsule() returned status %d. \n", status_);
    }


};

